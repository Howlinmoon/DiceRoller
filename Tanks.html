<!doctype html>
<html>
<head>
<meta charset=utf-8>
<title>Tanks</title>
<style>
body {
	margin: 40px;
	background: #666;
}

#my_canvas {
	background: #fff;
	border: #000 1px solid;
}
</style>

<script src = "CollisionAvoidance.js"></script>

<script>
	var enemyTankBase = new Image();
	enemyTankBase.src = "graphics/ETankBottom/Default/000.png";
	var enemyTankGun = new Image();
	enemyTankGun.src = "graphics/ETankTop/Default/000.png";

	var playerTankBase = new Image();
	playerTankBase.src = "graphics/TankBottom/Default/000.png";
	var playerTankGun = new Image();
	playerTankGun.src = "graphics/TankTop/Default/000.png";

	var backgroundImage = new Image();
	backgroundImage.src = "graphics/tiledbackground.png";

	var TO_RADIANS = Math.PI / 180;
	var animateInterval;
	
	// declare an array to hold a bunch of enemy tank objects
	var enemyTanks = [];
	
	// make our player tank global also
	var playerTank;

	// This class is for all entities that move around the map
	function VehicleClass() {
		// Vehicles have these common properties:
		// X location, Y location,  Direction (heading), Velocity, damage (health)
		// a graphic image
		// and an Id?
		this.x = 0, this.y = 0, this.heading = 0, this.health = 100,
				this.id = 0, this.velocity = 0;
		this.vehicleImage = new Image();
	}

	// establish a class for the Tanks

	function TankClass() {
		// the tanks require these additional properties:
		// direction of  turret
		// gun ammo,  mine ammo
		// current target X,Y
		// target acquired true/false
		this.turretDir = 0, this.gunAmmo = 100, this.mines = 10,
				this.targetX = 0, this.targetY = 0, this.targetAcquired = false;
		this.gunRange = 150, this.scanRange = 200;
		this.tankMethod = function tankMethod(arg1) {
			return arg1 + " Tank Method reporting for duty - ID: " + this.id;
		}
	}

	// Establish a class for enemy tanks
	function EnemyTankClass(arg1) {
		// enemy tanks require these additional properties:
		// a graphic image, a behavior
		this.vehicleImage = enemyTankBase, this.behavior = "wallFollow";
		this.enemyTankMethod = function enemyTankMethod(arg1) {
			return arg1 + "Enemy Tank Method reporting for duty - ID: "
					+ this.id;
		}
		// assign the passed Id to the tank
		this.id = arg1;
	}

	// Establish a class for player tanks
	function PlayerTankClass(arg1) {
		// player tanks require these additional properties:
		// a graphic image
		this.vehicleImage = playerTankBase
		this.playerTankMethod = function playerTankMethod(arg1) {
			return arg1 + "Player Tank Method reporting for duty - ID: "
					+ this.id;
		}
		// assign the passed Id to the tank
		this.id = arg1;
	}

	
	
	// Make the child class inherit all of the parent class characteristics
	// by using the prototype property

	// First, we make the tank class inherit the base vehicle class
	TankClass.prototype = new VehicleClass();

	// Next, we make the enemy tank class inherit the base tank class
	EnemyTankClass.prototype = new TankClass;

	// At this point, the following should create a new enemy tank object:
	var enemyTank1 = new EnemyTankClass('666');

	// Attempt to verify the classes are working correctly
	console.log("enemyTank1 - checking EnemyTankClass behavior property: "
			+ enemyTank1.behavior);
	console.log("enemyTank1 - calling the EnemyTankClass enemyTankMethod: "
			+ enemyTank1.enemyTankMethod(' sample data '));
	console.log("enemyTank1 - Displaying how many mines are available: "
			+ enemyTank1.mines);
	console.log("enemyTank1 - calling tankMethod with argument '999' "
			+ enemyTank1.tankMethod('999'));

	var angle = 0;
	var ctx = 0;

	function InitGame() {
		ctx = document.getElementById('my_canvas').getContext('2d');
		console.log(ctx.canvas.id + " | " + ctx.canvas.width + " | "
				+ ctx.canvas.height);

		// create a bunch of enemy tanks
		// 0 = right
		// 90 = up
		// 180 = left
		// 270 = down

		for (var tankCounter = 1; tankCounter <= 1; tankCounter++) {
			// Spawn a new enemy tank, and assign it's id
			var newEnemyTankObject = new EnemyTankClass(tankCounter);
			// assign initial X and Y co-ords
			// randomize them anywhere on the canvas - minus a 100 pix border
			newEnemyTankObject.x = Math.floor(Math.random()
					* (ctx.canvas.width - 100)) + 1;
			newEnemyTankObject.y = Math.floor(Math.random()
					* (ctx.canvas.height - 100)) + 1;
			// randomize an initial heading - using the compass points
			newEnemyTankObject.heading = (90 * (Math.floor(Math.random() * 4) ) );
			// randomize an initial velocity 1 - 5
			newEnemyTankObject.velocity = 5 ;
			
			// add this new tank to our array
			enemyTanks.push(newEnemyTankObject);
			console.log("Added tank " + tankCounter + " added to the array");
		}
		
		// create a single target tank
		playerTank = new PlayerTankClass(1);
		// assign initial X and Y co-ords
		// randomize them anywhere on the canvas - minus a 100 pix border
		playerTank.x = Math.floor(Math.random()
				* (ctx.canvas.width - 100)) + 1;
		playerTank.y = Math.floor(Math.random()
				* (ctx.canvas.height - 100)) + 1;
		// randomize a heading (1 - 4)
		playerTank.heading = Math.floor(Math.random() * 4) + 1;

		// collision testing using enemy tank #2
		playerTank.x = 250;
		playerTank.y = 250;
		playerTank.velocity = 0;
		enemyTanks[0].x = 50;
		enemyTanks[0].y = 250;
		enemyTanks[0].heading = 0;

		// how many enemy tanks in the array?
		console.log("Size of enemy tank array: " + enemyTanks.length);

		animateInterval = setInterval(animate, 100);
		//setInterval("animate()", 100);

	}

	function animate() {
		// Draw the background
		var ptrn = ctx.createPattern(backgroundImage, 'repeat'); // Create a pattern with this image, and set it to "repeat".
		// save the state of the context
		ctx.save();
		ctx.fillStyle = ptrn;
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height); // context.fillRect(x, y, width, height);
		// restore the state
		ctx.restore();

		// increment our global angle
		angle += 10;
		if (angle > 360) {
			angle = 0;
		}

		
		
		for (var tankNumber = 0; tankNumber < enemyTanks.length; tankNumber++) {
			enemyTanks[tankNumber].heading = angle;
			console.log("Tank number: "+tankNumber+", current heading: "+enemyTanks[tankNumber].heading+", Behavior: "+enemyTanks[tankNumber].behavior);
			console.log("Tank Velocity: "+enemyTanks[tankNumber].velocity);
			
			// determine if forward progress will hit an object
			// start with the walls
			// compute our new hypothetical X,Y if we continue in this direction at our current speed
			// enemyTanks[tankNumber].velocity = 20;
			var hypoX = enemyTanks[tankNumber].x + Math.cos(enemyTanks[tankNumber].heading * TO_RADIANS) *  enemyTanks[tankNumber].velocity * 10;
			var hypoY = enemyTanks[tankNumber].y + Math.sin(enemyTanks[tankNumber].heading * TO_RADIANS)  * enemyTanks[tankNumber].velocity * 10;
			
			
			console.log("Hypothetical X,Y: "+hypoX+" , "+hypoY);
			console.log("Actual X,Y: "+enemyTanks[tankNumber].x+" , "+enemyTanks[tankNumber].y);			
//		    enemyTanks[tankNumber].velocity = 0;
			
			// will it hit a wall?
			if ( hypoX < 10 ) {
				// hit the west wall - reverse direction, and place tank away from the wall.
				enemyTanks[tankNumber].velocity = -enemyTanks[tankNumber].velocity;
				enemyTanks[tankNumber].x = 20;
			}
				
			if (hypoX > (ctx.canvas.width - 10))  {
				// hit the east wall - reverse direction, and place tank away from the wall.
				enemyTanks[tankNumber].velocity = -enemyTanks[tankNumber].velocity;
				enemyTanks[tankNumber].x = (ctx.canvas.width - 20);
			}
			
			if ( hypoY < 10 ) {
				// hit the north wall - reverse direction, and place tank away from the wall.
				enemyTanks[tankNumber].velocity = -enemyTanks[tankNumber].velocity;
				//enemyTanks[tankNumber].y = 20;
			}
				
			if (hypoY > (ctx.canvas.height - 10))  {
				// hit the south wall - reverse direction, and place tank away from the wall.
				enemyTanks[tankNumber].velocity = -enemyTanks[tankNumber].velocity;
				//enemyTanks[tankNumber].y = (ctx.canvas.height - 20);
			}
			
	
			// will it hit another tank?  note - we now might be in risk of backing into one to avoid a wall!
			// run through all of the current enemy tanks
			/*
			for (var checkTank = 1; checkTank <enemyTanks.length; checkTank++ ) {
				if (checkTank != tankNumber) {
					// we don't check for collisions with ourself!
					// (start_x1, start_y1, dir1, velo1, start_x2, start_y2, dir2, velo2)
					if ( willCollide(enemyTanks[tankNumber].x,
							enemyTanks[tankNumber].y,
							enemyTanks[tankNumber].heading,
							enemyTanks[tankNumber].velocity * 4,
							enemyTanks[checkTank].x,
							enemyTanks[checkTank].y,
							enemyTanks[checkTank].heading,
							enemyTanks[checkTank].velocity * 4)) {
						console.log("Tank "+tankNumber+" will collide with Tank "+checkTank+" if it continues - stopping");
						enemyTanks[tankNumber].velocity = 0;
						clearInterval(animateInterval);  // stop the animation loop

					} else {
						console.log("Tank "+tankNumber+" will NOT collide with Tank "+checkTank);
					}
				}
			}
			*/
			
			console.log("Player Tank Direction and Velocity: "+playerTank.heading+" , "+playerTank.velocity);
			// check to make sure we will not collide with the target tank if we keeo moving
			// this check is to PREVENT a collision not to DETECT one
			
			// player tank  bounding box: ctx.strokeRect(playerTank.x - 40, playerTank.y - 34, 76, 74)
			// enemy tank bounding box: ctx.strokeRect(hypoX-40, hypoY, 76, 37);

			var boundBoxX = playerTank.x - 40;
			var boundBoxY = playerTank.y - 34;
			var playerTankW = 76;
			var playerTankH = 74;
			
			var collideX = false;
			var collideY = false;
			if (hypoX + 40 >= boundBoxX && hypoX - 40 <= boundBoxX ) {
				console.log("Possible Collision on the X detected");
				collideX = true;
			} else {
				console.log("No collision on the X detected");
			}
			
			if (hypoY  >= boundBoxY && hypoY <= boundBoxY + playerTankH ) {
				console.log("Possible Collision on the Y detected");
				collideY = true;
			} else {
				console.log("No collision on the Y detected");
			}

			if (collideX && collideY) {
				console.log("Tank "+tankNumber+" will collide with Player Tank if it continues - stopping");
				enemyTanks[tankNumber].velocity = 0;
				clearInterval(animateInterval);  // stop the animation loop
			}
			
			// enemyTanks[tankNumber].velocity * 10
			// attempt to create the collision triangle
			var lengthCQ = 65.81;
			var lengthAB = 76.0;
			var lengthAC = 76.0;
			var angleC = 60;
			var Qx = enemyTanks[tankNumber].x + Math.cos(enemyTanks[tankNumber].heading * TO_RADIANS) *  76;
			var Qy = enemyTanks[tankNumber].y + Math.sin(enemyTanks[tankNumber].heading * TO_RADIANS)  * 76;
			var Cx = enemyTanks[tankNumber].x;
			var Cy = enemyTanks[tankNumber].y;
			var Ax = lengthAC * (  -1 *   Math.sin( ( (angleC / 2) - enemyTanks[tankNumber].heading) * TO_RADIANS));
			var Ay = lengthAC * (      Math.cos( ( (angleC / 2) - enemyTanks[tankNumber].heading) * TO_RADIANS));
			var Bx = lengthAB * (   -1 *    Math.sin( ( (angleC / 2) - enemyTanks[tankNumber].heading) * TO_RADIANS));
			var By = lengthAB * (-1 * Math.cos( ( (angleC / 2) - enemyTanks[tankNumber].heading) * TO_RADIANS));
			
			console.log("Triangle:  Cx, Cy   Ax,Ay  Bx,By "+Cx+" , "+Cy+"  "+Ax+" , "+Ay+"  "+Bx+" , "+By);

			// apply them as offsets to see what happens
			var T1x = enemyTanks[tankNumber].x;
			var T1y = enemyTanks[tankNumber].y;
			
			var T2x = enemyTanks[tankNumber].x + Ax;
			var T2y = enemyTanks[tankNumber].y + Ay;
			
			var T3x = enemyTanks[tankNumber].x + Bx;
			var T3y = enemyTanks[tankNumber].y + By;

			
			// go ahead and move if you can
			if (enemyTanks[tankNumber].velocity != 0) {
				enemyTanks[tankNumber].x = enemyTanks[tankNumber].x += Math.cos(enemyTanks[tankNumber].heading * TO_RADIANS) * enemyTanks[tankNumber].velocity;
				enemyTanks[tankNumber].y = enemyTanks[tankNumber].y += Math.sin(enemyTanks[tankNumber].heading * TO_RADIANS) * enemyTanks[tankNumber].velocity;

			}

/*			
			switch (enemyTanks[tankNumber].heading) {
			case 1:
				enemyTanks[tankNumber].x += 5;
				if (enemyTanks[tankNumber].x > (ctx.canvas.width - 50)) {
					enemyTanks[tankNumber].heading = 2;
				}
				break;

			case 2:
				enemyTanks[tankNumber].y -= 5;
				if (enemyTanks[tankNumber].y < 50) {
					enemyTanks[tankNumber].heading = 3;
				}
				break;

			case 3:
				enemyTanks[tankNumber].x -= 5;
				if (enemyTanks[tankNumber].x < 50) {
					enemyTanks[tankNumber].heading = 4;
				}
				break;

			case 4:
				enemyTanks[tankNumber].y += 5;
				if (enemyTanks[tankNumber].y > (ctx.canvas.height - 50)) {
					enemyTanks[tankNumber].heading = 1;
				}
				break;

			}
*/
			//console.log("gun width: "+enemyTankGun.width+", height: "+enemyTankGun.height);
			// gun width: 72, height: 42

			drawRotatedImage(enemyTanks[tankNumber].vehicleImage,
					enemyTanks[tankNumber].x, enemyTanks[tankNumber].y,
					enemyTanks[tankNumber].heading , ctx);
			// and the gun - always point it at the center of the map
			// var angleDeg = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
			var centerX = ctx.canvas.width / 2;
			var centerY = ctx.canvas.height / 2;
			var gunAngle = Math.atan2(centerY - enemyTanks[tankNumber].y,
					centerX - enemyTanks[tankNumber].x)
					* 180 / Math.PI;

			//		drawRotatedImage(enemyTankGun, eTankX +gunXd, eTankY+gunYd, gunAngle, ctx);
			ctx.save();
			ctx.translate(enemyTanks[tankNumber].x, enemyTanks[tankNumber].y);
			ctx.rotate(gunAngle * Math.PI / 180);
			ctx.drawImage(enemyTankGun, -20, -22);
			ctx.restore();
			
/*
			// show our gunRange and scanRange
			// scan range
		    ctx.beginPath();
		    ctx.arc(enemyTanks[tankNumber].x, enemyTanks[tankNumber].y, enemyTanks[tankNumber].scanRange, 0, 2 * Math.PI, false);
//		    ctx.fillStyle = 'green';
//		    ctx.fill();
		    ctx.lineWidth = 5;
		    ctx.strokeStyle = 'green';
		    ctx.stroke();

		    // gun range
		    ctx.beginPath();
		    ctx.arc(enemyTanks[tankNumber].x, enemyTanks[tankNumber].y, enemyTanks[tankNumber].gunRange, 0, 2 * Math.PI, false);
		    ctx.lineWidth = 5;
		    ctx.strokeStyle = 'red';
		    ctx.stroke();

		    // collision range
		    ctx.beginPath();
		    // context.arc(x, y, radius, startAngle, endAngle, anticlockwise);
		    ctx.arc(enemyTanks[tankNumber].x, enemyTanks[tankNumber].y, 20 * 4 , 0, 2 * Math.PI, false);
		    ctx.lineWidth = 5;
		    ctx.strokeStyle = 'blue';
		    ctx.stroke();
			*/

		}
		
		// Draw the target (Player) tank
		drawRotatedImage(playerTank.vehicleImage, playerTank.x, playerTank.y, 0, ctx);
		// Draw the target (Player) tank turret
		ctx.save();
		ctx.translate(playerTank.x, playerTank.y);
		ctx.rotate(angle * Math.PI / 180);
		ctx.drawImage(playerTankGun, -20, -22);
		ctx.restore();
		
		// Draw the hypothetical projected point
	    ctx.beginPath();
	    ctx.arc(hypoX, hypoY, 5 , 0, 2 * Math.PI, false);
	    ctx.lineWidth = 5;
	    ctx.strokeStyle = 'red';
	    ctx.stroke();

	    // Draw the enemy tank's actual X,Y co-ordinate point
	    ctx.beginPath();
	    ctx.arc(enemyTanks[0].x, enemyTanks[0].y, 5 , 0, 2 * Math.PI, false);
	    ctx.lineWidth = 5;
	    ctx.strokeStyle = 'yellow';
	    ctx.stroke();

	    // Draw the player tank's actual X,Y co-ordinate point
	    ctx.beginPath();
	    ctx.arc(playerTank.x, playerTank.y, 5 , 0, 2 * Math.PI, false);
	    ctx.lineWidth = 5;
	    ctx.strokeStyle = 'yellow';
	    ctx.stroke();
	    
	    // Draw bounding boxes
	    
	    ctx.strokeRect(playerTank.x - 40, playerTank.y - 34, 76, 74)
	    
		// Draw the collision rectangle
		// CQ = enemyTanks[tankNumber].velocity * 10;
	    // QA = 1/2 tank width or 30 roughly
	    
		console.log("Triangle:  T1x, T1y   T2x,T2y  T3x,T3y "+T1x+" , "+T1y+"  "+T2x+" , "+T2y+"  "+T3x+" , "+T3y);

		
		ctx.moveTo(T1x, T1y);
		ctx.lineTo(T2x, T2y);
		ctx.lineTo(T3x, T3y);
		ctx.closePath();
		ctx.stroke();



	}

	function drawRotatedImage(image, x, y, angle, ctx) {

		// save the current co-ordinate system 
		// before we screw with it
		ctx.save();

		// move to the middle of where we want to draw our image
		ctx.translate(x, y);

		// rotate around that point, converting our 
		// angle from degrees to radians 
		ctx.rotate(angle * TO_RADIANS);

		// draw it up and to the left by half the width
		// and height of the image 
		ctx.drawImage(image, -(image.width / 2), -(image.height / 2));

		// and restore the co-ords to how they were when we began
		ctx.restore();
	}

	function randomNumber(min, max) {
		return Math.floor(Math.random() * (max - min)) + min;
	}

	window.addEventListener('load', function(event) {
		InitGame();
	});
</script>

</head>

<body>

	<script>
		
	</script>

	<canvas id="my_canvas" width="1280" height="512"></canvas>


</body>
</html>

